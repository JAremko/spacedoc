(ns spacetools.spacedoc.node-impl
  "`defnode` and `defnode*` implementation. Highly meh."
  (:require [clojure.spec.alpha :as s]
            [clojure.string :as str]
            [orchestra.core :refer [defn-spec]]
            [spacetools.spacedoc.core :as sc]))


(def unqualified-keyword? (complement qualified-keyword?))


(defn-spec unqualify-kv unqualified-keyword?
  "Makes keyword unqualified."
  [q-kv qualified-keyword?]
  (keyword (name q-kv)))


(defn-spec sdn-key-rank int?
  "Ranks keys of SDN nodes.
Used for sorting args in auto-generated node constructors."
  [sdn-key unqualified-keyword?]
  (sdn-key
   {:tag (Integer/MIN_VALUE)
    :key (inc Integer/MIN_VALUE)
    :value (+ 2 (Integer/MIN_VALUE))
    :type -2
    :path -1
    ;; Everything else here

    ;; Always last
    :children (Integer/MAX_VALUE)}
   0))


(defn-spec map-spec->keys (partial every? qualified-keyword?)
  "Extremely naive way to scoop keywords from map-spec."
  [spec-form list?]
  (->> spec-form
       (tree-seq #(list? %) rest)
       (mapcat #(when (vector? %) %))
       (set)
       (sort-by (comp sdn-key-rank unqualify-kv))))


(defn-spec defnode-spec-args seq?
  "If You read this - I'm sorry...
NOTE: Hopefully will be able to clean this up wit spec2."
  [q-keys (partial every? qualified-keyword?)]
  (let [key-map (zipmap (mapv unqualify-kv q-keys) q-keys)
        q-keys-no-ch (remove #(#{(:children key-map)} %) q-keys)
        ch-s (:children key-map)
        ch-s-f (when ch-s (s/form (s/get-spec ch-s)))]
    (concat (interleave (map unqualify-kv q-keys-no-ch) q-keys-no-ch)
            (condp = (some-> ch-s-f first name)
              "coll-of" [:children `(s/+ ~(second ch-s-f))]
              "cat" (rest ch-s-f)
              nil []
              (throw (ex-info "Can't generate children args with:"
                              {:keys q-keys}))))))


(defn-spec defnode-impl seq?
  [k qualified-keyword? con? boolean? spec-form list?]
  (let [tag (unqualify-kv k)
        q-ks (map-spec->keys spec-form)
        arg-tmpl (mapv (comp symbol name) q-ks)
        ret-tmpl (replace {'children '(vec children)} arg-tmpl)
        f-name (symbol (name k))
        tag-spec-k (keyword (str (namespace k) "." (name k)) "tag")
        arg-l (when con? (defnode-spec-args q-ks))]
    (list*
     `do
     ;; Register node tag
     `(defmethod sc/node->spec-k ~tag [_#] ~k)
     ;; Define tag spec
     `(s/def ~tag-spec-k #{~tag})
     ;; Define node spec
     `(s/def ~k (s/merge (s/keys :req-un [~tag-spec-k]) ~spec-form))
     (when con?
       `(;; Constructor function's spec
         (s/fdef ~f-name
           :args (s/cat ~@arg-l)
           :ret ~k)
         ;; Constructor function's definition
         (defn ^:autogenerated ~f-name
           ;; Doc-string
           ~(format "\"%s\" node constructor [AUTO-GENERATED]" k)
           ;; Args
           ~(vec (flatten (replace {'children ['& 'children]}  arg-tmpl)))
           ;; Returned value
           ~(merge {:tag tag} (zipmap (mapv unqualify-kv q-ks) ret-tmpl))))))))


(defmacro defnode
  "Define node, its spec and constructor by SPEC-FORM. K is the spec key.
  NOTE: This macro has limitations:
  - Currently it works only with `s/keys` and `s/merge` forms
    in the node spec and doesn't resolving sub-specs specified by keywords.
    See `map-spec->keys` implementation.
  - When generating constructors the children specs can only be
    `s/coll-of` or `s/cat` forms. To skip this step use `defnode*`."
  [k spec-form] (defnode-impl k true spec-form))


(defmacro defnode*
  "Same as `defnode` but doesn't create constructor."
  [k spec-form] (defnode-impl k false spec-form))
